//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    compile(body: CodeRequest | undefined): Promise<CompilationResult> {
        let url_ = this.baseUrl + "/api/code/compile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompile(_response);
        });
    }

    protected processCompile(response: Response): Promise<CompilationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompilationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompilationResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completion(body: CompletionRequest | undefined): Promise<CompletionItem[]> {
        let url_ = this.baseUrl + "/api/Completion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompletion(_response);
        });
    }

    protected processCompletion(response: Response): Promise<CompletionItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompletionItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompletionItem[]>(null as any);
    }

    /**
     * @return Success
     */
    syntax(): Promise<SyntaxConfig> {
        let url_ = this.baseUrl + "/api/EditorConfig/syntax";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSyntax(_response);
        });
    }

    protected processSyntax(response: Response): Promise<SyntaxConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SyntaxConfig.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SyntaxConfig>(null as any);
    }
}

export class AutoClosingPair implements IAutoClosingPair {
    open?: string | undefined;
    close?: string | undefined;

    constructor(data?: IAutoClosingPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.open = _data["open"];
            this.close = _data["close"];
        }
    }

    static fromJS(data: any): AutoClosingPair {
        data = typeof data === 'object' ? data : {};
        let result = new AutoClosingPair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["open"] = this.open;
        data["close"] = this.close;
        return data;
    }
}

export interface IAutoClosingPair {
    open?: string | undefined;
    close?: string | undefined;
}

export class AutoClosingPairConditional implements IAutoClosingPairConditional {
    open?: string | undefined;
    close?: string | undefined;
    notIn?: string[] | undefined;

    constructor(data?: IAutoClosingPairConditional) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.open = _data["open"];
            this.close = _data["close"];
            if (Array.isArray(_data["notIn"])) {
                this.notIn = [] as any;
                for (let item of _data["notIn"])
                    this.notIn!.push(item);
            }
        }
    }

    static fromJS(data: any): AutoClosingPairConditional {
        data = typeof data === 'object' ? data : {};
        let result = new AutoClosingPairConditional();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["open"] = this.open;
        data["close"] = this.close;
        if (Array.isArray(this.notIn)) {
            data["notIn"] = [];
            for (let item of this.notIn)
                data["notIn"].push(item);
        }
        return data;
    }
}

export interface IAutoClosingPairConditional {
    open?: string | undefined;
    close?: string | undefined;
    notIn?: string[] | undefined;
}

export class CharacterPair implements ICharacterPair {
    open?: string | undefined;
    close?: string | undefined;

    constructor(data?: ICharacterPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.open = _data["open"];
            this.close = _data["close"];
        }
    }

    static fromJS(data: any): CharacterPair {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterPair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["open"] = this.open;
        data["close"] = this.close;
        return data;
    }
}

export interface ICharacterPair {
    open?: string | undefined;
    close?: string | undefined;
}

export class CodeRequest implements ICodeRequest {
    code?: string | undefined;

    constructor(data?: ICodeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CodeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CodeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data;
    }
}

export interface ICodeRequest {
    code?: string | undefined;
}

export class CommentRule implements ICommentRule {
    lineComment?: string | undefined;
    blockComment?: CharacterPair;

    constructor(data?: ICommentRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lineComment = _data["lineComment"];
            this.blockComment = _data["blockComment"] ? CharacterPair.fromJS(_data["blockComment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentRule {
        data = typeof data === 'object' ? data : {};
        let result = new CommentRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineComment"] = this.lineComment;
        data["blockComment"] = this.blockComment ? this.blockComment.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentRule {
    lineComment?: string | undefined;
    blockComment?: CharacterPair;
}

export class CompilationError implements ICompilationError {
    startLine?: number;
    startColumn?: number;
    endLine?: number;
    endColumn?: number;
    message?: string | undefined;
    severity?: string | undefined;

    constructor(data?: ICompilationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startLine = _data["startLine"];
            this.startColumn = _data["startColumn"];
            this.endLine = _data["endLine"];
            this.endColumn = _data["endColumn"];
            this.message = _data["message"];
            this.severity = _data["severity"];
        }
    }

    static fromJS(data: any): CompilationError {
        data = typeof data === 'object' ? data : {};
        let result = new CompilationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startLine"] = this.startLine;
        data["startColumn"] = this.startColumn;
        data["endLine"] = this.endLine;
        data["endColumn"] = this.endColumn;
        data["message"] = this.message;
        data["severity"] = this.severity;
        return data;
    }
}

export interface ICompilationError {
    startLine?: number;
    startColumn?: number;
    endLine?: number;
    endColumn?: number;
    message?: string | undefined;
    severity?: string | undefined;
}

export class CompilationResult implements ICompilationResult {
    success?: boolean;
    output?: string | undefined;
    errors?: CompilationError[] | undefined;

    constructor(data?: ICompilationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.output = _data["output"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(CompilationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompilationResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompilationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["output"] = this.output;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICompilationResult {
    success?: boolean;
    output?: string | undefined;
    errors?: CompilationError[] | undefined;
}

export class CompletionItem implements ICompletionItem {
    label?: string | undefined;
    kind?: string | undefined;
    insertText?: string | undefined;
    detail?: string | undefined;
    documentation?: string | undefined;
    commitCharacters?: string[] | undefined;
    insertTextRules?: string | undefined;

    constructor(data?: ICompletionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.kind = _data["kind"];
            this.insertText = _data["insertText"];
            this.detail = _data["detail"];
            this.documentation = _data["documentation"];
            if (Array.isArray(_data["commitCharacters"])) {
                this.commitCharacters = [] as any;
                for (let item of _data["commitCharacters"])
                    this.commitCharacters!.push(item);
            }
            this.insertTextRules = _data["insertTextRules"];
        }
    }

    static fromJS(data: any): CompletionItem {
        data = typeof data === 'object' ? data : {};
        let result = new CompletionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["kind"] = this.kind;
        data["insertText"] = this.insertText;
        data["detail"] = this.detail;
        data["documentation"] = this.documentation;
        if (Array.isArray(this.commitCharacters)) {
            data["commitCharacters"] = [];
            for (let item of this.commitCharacters)
                data["commitCharacters"].push(item);
        }
        data["insertTextRules"] = this.insertTextRules;
        return data;
    }
}

export interface ICompletionItem {
    label?: string | undefined;
    kind?: string | undefined;
    insertText?: string | undefined;
    detail?: string | undefined;
    documentation?: string | undefined;
    commitCharacters?: string[] | undefined;
    insertTextRules?: string | undefined;
}

export class CompletionRequest implements ICompletionRequest {
    code?: string | undefined;
    position?: number;

    constructor(data?: ICompletionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): CompletionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CompletionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["position"] = this.position;
        return data;
    }
}

export interface ICompletionRequest {
    code?: string | undefined;
    position?: number;
}

export class DocComment implements IDocComment {
    open?: string | undefined;
    close?: string | undefined;

    constructor(data?: IDocComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.open = _data["open"];
            this.close = _data["close"];
        }
    }

    static fromJS(data: any): DocComment {
        data = typeof data === 'object' ? data : {};
        let result = new DocComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["open"] = this.open;
        data["close"] = this.close;
        return data;
    }
}

export interface IDocComment {
    open?: string | undefined;
    close?: string | undefined;
}

export class ElectricCharacterSupport implements IElectricCharacterSupport {
    docComment?: DocComment;

    constructor(data?: IElectricCharacterSupport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docComment = _data["docComment"] ? DocComment.fromJS(_data["docComment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ElectricCharacterSupport {
        data = typeof data === 'object' ? data : {};
        let result = new ElectricCharacterSupport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docComment"] = this.docComment ? this.docComment.toJSON() : <any>undefined;
        return data;
    }
}

export interface IElectricCharacterSupport {
    docComment?: DocComment;
}

export class EnterAction implements IEnterAction {
    indentAction?: string | undefined;
    appendText?: string | undefined;
    removeText?: number | undefined;

    constructor(data?: IEnterAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.indentAction = _data["indentAction"];
            this.appendText = _data["appendText"];
            this.removeText = _data["removeText"];
        }
    }

    static fromJS(data: any): EnterAction {
        data = typeof data === 'object' ? data : {};
        let result = new EnterAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indentAction"] = this.indentAction;
        data["appendText"] = this.appendText;
        data["removeText"] = this.removeText;
        return data;
    }
}

export interface IEnterAction {
    indentAction?: string | undefined;
    appendText?: string | undefined;
    removeText?: number | undefined;
}

export class FoldingMarkers implements IFoldingMarkers {
    start?: string | undefined;
    end?: string | undefined;

    constructor(data?: IFoldingMarkers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"];
            this.end = _data["end"];
        }
    }

    static fromJS(data: any): FoldingMarkers {
        data = typeof data === 'object' ? data : {};
        let result = new FoldingMarkers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["end"] = this.end;
        return data;
    }
}

export interface IFoldingMarkers {
    start?: string | undefined;
    end?: string | undefined;
}

export class FoldingRules implements IFoldingRules {
    offSide?: boolean | undefined;
    markers?: FoldingMarkers;

    constructor(data?: IFoldingRules) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offSide = _data["offSide"];
            this.markers = _data["markers"] ? FoldingMarkers.fromJS(_data["markers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FoldingRules {
        data = typeof data === 'object' ? data : {};
        let result = new FoldingRules();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offSide"] = this.offSide;
        data["markers"] = this.markers ? this.markers.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFoldingRules {
    offSide?: boolean | undefined;
    markers?: FoldingMarkers;
}

export class IndentationRule implements IIndentationRule {
    decreaseIndentPattern?: string | undefined;
    increaseIndentPattern?: string | undefined;
    indentNextLinePattern?: string | undefined;
    unIndentedLinePattern?: string | undefined;

    constructor(data?: IIndentationRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.decreaseIndentPattern = _data["decreaseIndentPattern"];
            this.increaseIndentPattern = _data["increaseIndentPattern"];
            this.indentNextLinePattern = _data["indentNextLinePattern"];
            this.unIndentedLinePattern = _data["unIndentedLinePattern"];
        }
    }

    static fromJS(data: any): IndentationRule {
        data = typeof data === 'object' ? data : {};
        let result = new IndentationRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["decreaseIndentPattern"] = this.decreaseIndentPattern;
        data["increaseIndentPattern"] = this.increaseIndentPattern;
        data["indentNextLinePattern"] = this.indentNextLinePattern;
        data["unIndentedLinePattern"] = this.unIndentedLinePattern;
        return data;
    }
}

export interface IIndentationRule {
    decreaseIndentPattern?: string | undefined;
    increaseIndentPattern?: string | undefined;
    indentNextLinePattern?: string | undefined;
    unIndentedLinePattern?: string | undefined;
}

export class LanguageConfiguration implements ILanguageConfiguration {
    comments?: CommentRule;
    brackets?: CharacterPair[] | undefined;
    wordPattern?: string | undefined;
    indentationRules?: IndentationRule;
    onEnterRules?: OnEnterRule[] | undefined;
    autoClosingPairs?: AutoClosingPairConditional[] | undefined;
    surroundingPairs?: AutoClosingPair[] | undefined;
    colorizedBracketPairs?: CharacterPair[] | undefined;
    autoCloseBefore?: string | undefined;
    folding?: FoldingRules;
    __electricCharacterSupport?: ElectricCharacterSupport;

    constructor(data?: ILanguageConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comments = _data["comments"] ? CommentRule.fromJS(_data["comments"]) : <any>undefined;
            if (Array.isArray(_data["brackets"])) {
                this.brackets = [] as any;
                for (let item of _data["brackets"])
                    this.brackets!.push(CharacterPair.fromJS(item));
            }
            this.wordPattern = _data["wordPattern"];
            this.indentationRules = _data["indentationRules"] ? IndentationRule.fromJS(_data["indentationRules"]) : <any>undefined;
            if (Array.isArray(_data["onEnterRules"])) {
                this.onEnterRules = [] as any;
                for (let item of _data["onEnterRules"])
                    this.onEnterRules!.push(OnEnterRule.fromJS(item));
            }
            if (Array.isArray(_data["autoClosingPairs"])) {
                this.autoClosingPairs = [] as any;
                for (let item of _data["autoClosingPairs"])
                    this.autoClosingPairs!.push(AutoClosingPairConditional.fromJS(item));
            }
            if (Array.isArray(_data["surroundingPairs"])) {
                this.surroundingPairs = [] as any;
                for (let item of _data["surroundingPairs"])
                    this.surroundingPairs!.push(AutoClosingPair.fromJS(item));
            }
            if (Array.isArray(_data["colorizedBracketPairs"])) {
                this.colorizedBracketPairs = [] as any;
                for (let item of _data["colorizedBracketPairs"])
                    this.colorizedBracketPairs!.push(CharacterPair.fromJS(item));
            }
            this.autoCloseBefore = _data["autoCloseBefore"];
            this.folding = _data["folding"] ? FoldingRules.fromJS(_data["folding"]) : <any>undefined;
            this.__electricCharacterSupport = _data["__electricCharacterSupport"] ? ElectricCharacterSupport.fromJS(_data["__electricCharacterSupport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LanguageConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments ? this.comments.toJSON() : <any>undefined;
        if (Array.isArray(this.brackets)) {
            data["brackets"] = [];
            for (let item of this.brackets)
                data["brackets"].push(item.toJSON());
        }
        data["wordPattern"] = this.wordPattern;
        data["indentationRules"] = this.indentationRules ? this.indentationRules.toJSON() : <any>undefined;
        if (Array.isArray(this.onEnterRules)) {
            data["onEnterRules"] = [];
            for (let item of this.onEnterRules)
                data["onEnterRules"].push(item.toJSON());
        }
        if (Array.isArray(this.autoClosingPairs)) {
            data["autoClosingPairs"] = [];
            for (let item of this.autoClosingPairs)
                data["autoClosingPairs"].push(item.toJSON());
        }
        if (Array.isArray(this.surroundingPairs)) {
            data["surroundingPairs"] = [];
            for (let item of this.surroundingPairs)
                data["surroundingPairs"].push(item.toJSON());
        }
        if (Array.isArray(this.colorizedBracketPairs)) {
            data["colorizedBracketPairs"] = [];
            for (let item of this.colorizedBracketPairs)
                data["colorizedBracketPairs"].push(item.toJSON());
        }
        data["autoCloseBefore"] = this.autoCloseBefore;
        data["folding"] = this.folding ? this.folding.toJSON() : <any>undefined;
        data["__electricCharacterSupport"] = this.__electricCharacterSupport ? this.__electricCharacterSupport.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILanguageConfiguration {
    comments?: CommentRule;
    brackets?: CharacterPair[] | undefined;
    wordPattern?: string | undefined;
    indentationRules?: IndentationRule;
    onEnterRules?: OnEnterRule[] | undefined;
    autoClosingPairs?: AutoClosingPairConditional[] | undefined;
    surroundingPairs?: AutoClosingPair[] | undefined;
    colorizedBracketPairs?: CharacterPair[] | undefined;
    autoCloseBefore?: string | undefined;
    folding?: FoldingRules;
    __electricCharacterSupport?: ElectricCharacterSupport;
}

export class MonarchLanguage implements IMonarchLanguage {
    tokenizer?: { [key: string]: MonarchLanguageRule[]; } | undefined;
    ignoreCase?: boolean | undefined;
    unicode?: boolean | undefined;
    defaultToken?: string | undefined;
    brackets?: MonarchLanguageBracket[] | undefined;
    start?: string | undefined;
    tokenPostfix?: string | undefined;
    includeLF?: boolean | undefined;

    [key: string]: any;

    constructor(data?: IMonarchLanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["tokenizer"]) {
                this.tokenizer = {} as any;
                for (let key in _data["tokenizer"]) {
                    if (_data["tokenizer"].hasOwnProperty(key))
                        (<any>this.tokenizer)![key] = _data["tokenizer"][key] ? _data["tokenizer"][key].map((i: any) => MonarchLanguageRule.fromJS(i)) : [];
                }
            }
            this.ignoreCase = _data["ignoreCase"];
            this.unicode = _data["unicode"];
            this.defaultToken = _data["defaultToken"];
            if (Array.isArray(_data["brackets"])) {
                this.brackets = [] as any;
                for (let item of _data["brackets"])
                    this.brackets!.push(MonarchLanguageBracket.fromJS(item));
            }
            this.start = _data["start"];
            this.tokenPostfix = _data["tokenPostfix"];
            this.includeLF = _data["includeLF"];
        }
    }

    static fromJS(data: any): MonarchLanguage {
        data = typeof data === 'object' ? data : {};
        let result = new MonarchLanguage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.tokenizer) {
            data["tokenizer"] = {};
            for (let key in this.tokenizer) {
                if (this.tokenizer.hasOwnProperty(key))
                    (<any>data["tokenizer"])[key] = (<any>this.tokenizer)[key];
            }
        }
        data["ignoreCase"] = this.ignoreCase;
        data["unicode"] = this.unicode;
        data["defaultToken"] = this.defaultToken;
        if (Array.isArray(this.brackets)) {
            data["brackets"] = [];
            for (let item of this.brackets)
                data["brackets"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["tokenPostfix"] = this.tokenPostfix;
        data["includeLF"] = this.includeLF;
        return data;
    }
}

export interface IMonarchLanguage {
    tokenizer?: { [key: string]: MonarchLanguageRule[]; } | undefined;
    ignoreCase?: boolean | undefined;
    unicode?: boolean | undefined;
    defaultToken?: string | undefined;
    brackets?: MonarchLanguageBracket[] | undefined;
    start?: string | undefined;
    tokenPostfix?: string | undefined;
    includeLF?: boolean | undefined;

    [key: string]: any;
}

export class MonarchLanguageAction implements IMonarchLanguageAction {
    group?: MonarchLanguageAction[] | undefined;
    cases?: { [key: string]: MonarchLanguageAction; } | undefined;
    token?: string | undefined;
    next?: string | undefined;
    switchTo?: string | undefined;
    goBack?: number | undefined;
    bracket?: string | undefined;
    nextEmbedded?: string | undefined;
    log?: string | undefined;

    constructor(data?: IMonarchLanguageAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["group"])) {
                this.group = [] as any;
                for (let item of _data["group"])
                    this.group!.push(MonarchLanguageAction.fromJS(item));
            }
            if (_data["cases"]) {
                this.cases = {} as any;
                for (let key in _data["cases"]) {
                    if (_data["cases"].hasOwnProperty(key))
                        (<any>this.cases)![key] = _data["cases"][key] ? MonarchLanguageAction.fromJS(_data["cases"][key]) : new MonarchLanguageAction();
                }
            }
            this.token = _data["token"];
            this.next = _data["next"];
            this.switchTo = _data["switchTo"];
            this.goBack = _data["goBack"];
            this.bracket = _data["bracket"];
            this.nextEmbedded = _data["nextEmbedded"];
            this.log = _data["log"];
        }
    }

    static fromJS(data: any): MonarchLanguageAction {
        data = typeof data === 'object' ? data : {};
        let result = new MonarchLanguageAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.group)) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item.toJSON());
        }
        if (this.cases) {
            data["cases"] = {};
            for (let key in this.cases) {
                if (this.cases.hasOwnProperty(key))
                    (<any>data["cases"])[key] = this.cases[key] ? this.cases[key].toJSON() : <any>undefined;
            }
        }
        data["token"] = this.token;
        data["next"] = this.next;
        data["switchTo"] = this.switchTo;
        data["goBack"] = this.goBack;
        data["bracket"] = this.bracket;
        data["nextEmbedded"] = this.nextEmbedded;
        data["log"] = this.log;
        return data;
    }
}

export interface IMonarchLanguageAction {
    group?: MonarchLanguageAction[] | undefined;
    cases?: { [key: string]: MonarchLanguageAction; } | undefined;
    token?: string | undefined;
    next?: string | undefined;
    switchTo?: string | undefined;
    goBack?: number | undefined;
    bracket?: string | undefined;
    nextEmbedded?: string | undefined;
    log?: string | undefined;
}

export class MonarchLanguageBracket implements IMonarchLanguageBracket {
    open?: string | undefined;
    close?: string | undefined;
    token?: string | undefined;

    constructor(data?: IMonarchLanguageBracket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.open = _data["open"];
            this.close = _data["close"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): MonarchLanguageBracket {
        data = typeof data === 'object' ? data : {};
        let result = new MonarchLanguageBracket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["open"] = this.open;
        data["close"] = this.close;
        data["token"] = this.token;
        return data;
    }
}

export interface IMonarchLanguageBracket {
    open?: string | undefined;
    close?: string | undefined;
    token?: string | undefined;
}

export class MonarchLanguageRule implements IMonarchLanguageRule {
    regex?: string | undefined;
    action?: MonarchLanguageAction;
    include?: string | undefined;

    constructor(data?: IMonarchLanguageRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regex = _data["regex"];
            this.action = _data["action"] ? MonarchLanguageAction.fromJS(_data["action"]) : <any>undefined;
            this.include = _data["include"];
        }
    }

    static fromJS(data: any): MonarchLanguageRule {
        data = typeof data === 'object' ? data : {};
        let result = new MonarchLanguageRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regex"] = this.regex;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["include"] = this.include;
        return data;
    }
}

export interface IMonarchLanguageRule {
    regex?: string | undefined;
    action?: MonarchLanguageAction;
    include?: string | undefined;
}

export class OnEnterRule implements IOnEnterRule {
    beforeText?: string | undefined;
    afterText?: string | undefined;
    previousLineText?: string | undefined;
    action?: EnterAction;

    constructor(data?: IOnEnterRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.beforeText = _data["beforeText"];
            this.afterText = _data["afterText"];
            this.previousLineText = _data["previousLineText"];
            this.action = _data["action"] ? EnterAction.fromJS(_data["action"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OnEnterRule {
        data = typeof data === 'object' ? data : {};
        let result = new OnEnterRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beforeText"] = this.beforeText;
        data["afterText"] = this.afterText;
        data["previousLineText"] = this.previousLineText;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOnEnterRule {
    beforeText?: string | undefined;
    afterText?: string | undefined;
    previousLineText?: string | undefined;
    action?: EnterAction;
}

export class SyntaxConfig implements ISyntaxConfig {
    monarchLanguage?: MonarchLanguage;
    languageConfiguration?: LanguageConfiguration;

    constructor(data?: ISyntaxConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.monarchLanguage = _data["monarchLanguage"] ? MonarchLanguage.fromJS(_data["monarchLanguage"]) : <any>undefined;
            this.languageConfiguration = _data["languageConfiguration"] ? LanguageConfiguration.fromJS(_data["languageConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SyntaxConfig {
        data = typeof data === 'object' ? data : {};
        let result = new SyntaxConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monarchLanguage"] = this.monarchLanguage ? this.monarchLanguage.toJSON() : <any>undefined;
        data["languageConfiguration"] = this.languageConfiguration ? this.languageConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISyntaxConfig {
    monarchLanguage?: MonarchLanguage;
    languageConfiguration?: LanguageConfiguration;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}